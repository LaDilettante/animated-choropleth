p + stat_summary(fun.y="median_hilow", geom="smooth")
p <- ggplot(data=diamonds, aes(carat, price))
p + stat_summary(fun.y="median_hilow", geom="smooth")
p + stat_summary(fun.y="median", geom="line")
p + stat_summary(fun.y="mean", geom="line")
p + stat_summary(fun.y="mean", geom="smooth")
p + stat_summary(fun.y="mean", geom="line")
help(geom_smooth)
library(XLConnect)
library(XLConnect)
find.java <- function() {
for (root in c("HLM", "HCU")) for (key in c("Software\\JavaSoft\\Java Runtime Environment",
"Software\\JavaSoft\\Java Development Kit")) {
hive <- try(utils::readRegistry(key, root, 2),
silent = TRUE)
if (!inherits(hive, "try-error"))
return(hive)
}
hive
}
find.java()
library(rJava)
library(XLConnect)
library(ggplot2)
q()
install.packages('digest')
library(ggplot2)
install.packages("plyr")
library(foreign)
install.packages('foreign')
library(ggplot2)
install.packages('colorspace')
install.packages('ggplot2')
library("ggplot2")
library("XLConnect")
library("rJava")
q()
# installing/loading the package:
if(!require(installr)) {
install.packages("installr"); require(installr)} #load / install+load installr
updateR() # this will only work AFTER R 3.0.0 will be released to your CRAN mirror
library(XLConnect)
update.packages(checkBuilt=TRUE)
y
update.packages(checkBuilt=TRUE)
update.packages(checkBuilt=TRUE)
library(XLConnect)
install.packages("XLConnect")
install.packages("ggplot2")
install.packages(gdata)
install.packages("gdata)
adsf
)
a""
""
install.packages("gdata")
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
install.packages("doBy")
library(mvtnorm)
rm(list=ls())
library(plyr)
bnames <- read.csv("bnames.csv", stringsAsFactors = FALSE)
head(bnames)
# Whole dataset transformations ---------------------------------------------
letter <- function(x, n = 1) {
if (n < 0) {
nc <- nchar(x)
n <- nc + n + 1
}
tolower(substr(x, n, n))
}
vowels <- function(x) {
nchar(gsub("[^aeiou]", "", x))
}
bnames <- transform(bnames,
first = letter(name, 1),
last = letter(name, -1),
length = nchar(name),
vowels = vowels(name)
)
bnames <- read.csv("bnames.csv", stringsAsFactors = FALSE)
getwd()
rm(list=ls())
library(ggplot2)
library(maps)
states <- map_data("state")
View(states)
arrests <- USArrests
help(USArrests)
View(arrests)
names(arrests) <- tolower(names(arrests))
View(arrests)
View(arrests)
rm(list=ls())
library(ggplot2)
library(maps)
states <- map_data("state")
arrests <- USArrests
view(arrests)
head(arrests)
names(arrests) <- tolower(names(arrests))
arrests$region <- tolower(rownames(USArrests))
head(arrests)
choro <- merge(states, arrests, by="region")
head(choro)
country <- map_data("world")
head(country)
head(temp)
temp <- subset(na.omit(wgi[, c('region', 'year', 'country', 'cc_est')]), year==2011)
rm(list=ls())
try(detach("package:Hmisc", unload=TRUE), silent=TRUE)
library(ggplot2)
library(reshape2)
library(plyr)
library(maps)
source("visual_func.R")
load("gov_clean.RData")
rm(list=ls())
library(animation)
library(ggplot2)
rm(list=ls())
library(animation)
library(ggplot2)
oopt <- ani.options(interval=0.2, nmax=1)
for (i in 1:ani.options("nmax")) {
plot(rnorm(30))
ani.pause()
}
ani.options(oopt)
ani.options(oopt)
rm(list=ls())
library(animation)
ani.options(interval=.05)
col.range <- heat.colors(15)
col.range
layout(matrix(c(1, rep(2, 5)), 6, 1))
saveGIF({
# For the most part, it’s safest to start with graphical settings in
# the animation loop, as the loop adds a layer of complexity to
# manipulating the graphs. For example, the layout specification needs to
# be within animation loop to work properly.
layout(matrix(c(1, rep(2, 5)), 6, 1))
# Adjust the margins a little
par(mar=c(4,4,2,1) + 0.1)
# Begin the loop that creates the 150 individual graphs
for (i in 1:150) {
# Pull 100 observations from a normal distribution
# and add a constant based on the iteration to move the distribution
chunk <- rnorm(100)+sqrt(abs((i)-51))
# Reset the color of the top chart every time (so that it doesn’t change as the
# bottom chart changes)
par(fg=1)
# Set up the top chart that keeps track of the current frame/iteration
# Dress it up a little just for fun
plot(-5, xlim = c(1,150), ylim = c(0, .3), axes = F, xlab = “”, ylab = “”, main = “Iteration”)
abline(v=i, lwd=5, col = rgb(0, 0, 255, 255, maxColorValue=255))
abline(v=i-1, lwd=5, col = rgb(0, 0, 255, 50, maxColorValue=255))
abline(v=i-2, lwd=5, col = rgb(0, 0, 255, 25, maxColorValue=255))
# Bring back the X axis
saveGIF({
# For the most part, it’s safest to start with graphical settings in
# the animation loop, as the loop adds a layer of complexity to
# manipulating the graphs. For example, the layout specification needs to
# be within animation loop to work properly.
layout(matrix(c(1, rep(2, 5)), 6, 1))
# Adjust the margins a little
par(mar=c(4,4,2,1) + 0.1)
# Begin the loop that creates the 150 individual graphs
for (i in 1:150) {
# Pull 100 observations from a normal distribution
# and add a constant based on the iteration to move the distribution
chunk <- rnorm(100)+sqrt(abs((i)-51))
# Reset the color of the top chart every time (so that it doesn’t change as the
# bottom chart changes)
par(fg=1)
# Set up the top chart that keeps track of the current frame/iteration
# Dress it up a little just for fun
plot(-5, xlim = c(1,150), ylim = c(0, .3), axes = F, xlab = “”, ylab = “”, main = “Iteration”)
abline(v=i, lwd=5, col = rgb(0, 0, 255, 255, maxColorValue=255))
abline(v=i-1, lwd=5, col = rgb(0, 0, 255, 50, maxColorValue=255))
abline(v=i-2, lwd=5, col = rgb(0, 0, 255, 25, maxColorValue=255))
# Bring back the X axis
axis(1)
# Set the color of the bottom chart based on the distance of the distribution’s mean from 0
par(fg = col.range[mean(chunk)+3])
# Set up the bottom chart
plot(density(chunk), main = “”, xlab = “X Value”, xlim = c(-5, 15), ylim = c(0, .6))
# Add a line that indicates the mean of the distribution. Add additional lines to track
# previous means
abline(v=mean(chunk), col = rgb(255, 0, 0, 255, maxColorValue=255))
if (exists(“lastmean”)) {abline(v=lastmean, col = rgb(255, 0, 0, 50, maxColorValue=255)); prevlastmean <- lastmean;}
if (exists(“prevlastmean”)) {abline(v=prevlastmean, col = rgb(255, 0, 0, 25, maxColorValue=255))}
#Fix last mean calculation
lastmean <- mean(chunk)
}
})
rm(list=ls())
library(animation)
#Set delay between frames when replaying
ani.options(interval=.05)
# Set up a vector of colors for use below
col.range <- heat.colors(15)
# Begin animation loop
# Note the brackets within the parentheses
saveGIF({
# For the most part, it’s safest to start with graphical settings in
# the animation loop, as the loop adds a layer of complexity to
# manipulating the graphs. For example, the layout specification needs to
# be within animation loop to work properly.
layout(matrix(c(1, rep(2, 5)), 6, 1))
# Adjust the margins a little
par(mar=c(4,4,2,1) + 0.1)
# Begin the loop that creates the 150 individual graphs
for (i in 1:150) {
# Pull 100 observations from a normal distribution
# and add a constant based on the iteration to move the distribution
chunk <- rnorm(100)+sqrt(abs((i)-51))
# Reset the color of the top chart every time (so that it doesn’t change as the
# bottom chart changes)
par(fg=1)
# Set up the top chart that keeps track of the current frame/iteration
# Dress it up a little just for fun
plot(-5, xlim = c(1,150), ylim = c(0, .3), axes = F, xlab = “”, ylab = “”, main = “Iteration”)
abline(v=i, lwd=5, col = rgb(0, 0, 255, 255, maxColorValue=255))
abline(v=i-1, lwd=5, col = rgb(0, 0, 255, 50, maxColorValue=255))
abline(v=i-2, lwd=5, col = rgb(0, 0, 255, 25, maxColorValue=255))
# Bring back the X axis
axis(1)
# Set the color of the bottom chart based on the distance of the distribution’s mean from 0
par(fg = col.range[mean(chunk)+3])
# Set up the bottom chart
plot(density(chunk), main = “”, xlab = “X Value”, xlim = c(-5, 15), ylim = c(0, .6))
# Add a line that indicates the mean of the distribution. Add additional lines to track
# previous means
abline(v=mean(chunk), col = rgb(255, 0, 0, 255, maxColorValue=255))
if (exists(“lastmean”)) {abline(v=lastmean, col = rgb(255, 0, 0, 50, maxColorValue=255)); prevlastmean <- lastmean;}
if (exists(“prevlastmean”)) {abline(v=prevlastmean, col = rgb(255, 0, 0, 25, maxColorValue=255))}
#Fix last mean calculation
lastmean <- mean(chunk)
}
})
saveGIF({
for (i in 1:10) plot(runif(10), ylim = 0:1)
})
saveHTML({
for (i in 1:10) plot(runif(10), ylim = 0:1)
})
install.packages("ggmap")
library(maps)
library(ggmap)
library(maptools)
install.packages("maptools")
library(rworldmap)
install.packages("rworldmap")
install.packages("rmapproj")
library(maps)
help(maps0)
help(maps)
vignette("sp")
install.packages("sp")
vignettes("ggmap")
vignette("ggmap")
vignette("sp")
library(ggmap)
library(mapproj)
map <- get_map(location = 'Europe', zoom = 4)
library(rworldmap)
newmap <- getMap(resolution = "low")
plot(newmap)
plot(newmap,
xlim = c(-20, 59),
ylim = c(35, 71),
asp = 1
)
newmap
fix(newmap)
getwd()
getwd(./)
setwd("./")
getwd()
setwd("D:/Github/animated-choropleth")
help(saveHTML)
rm(list=ls())
toInstall <- c("ggplot2", "maptools", "animation", "rgdal")
lapply(toInstall, library, character.only=TRUE)
help(saveHTML)
rm(list=ls())
toInstall <- c("ggplot2", "maptools", "animation", "rgdal")
lapply(toInstall, library, character.only=TRUE)
# Load and clean WGI data
load('./data/wgi_cleaned.RData')
# Load world map shape file
world.map <- readOGR(dsn="./data", layer="TM_WORLD_BORDERS_SIMPL-0.3")
world.ggmap <- fortify(world.map, region = "NAME")
# Fix mismatched names
wgi$country[wgi$country=="Brunei"] <- "Brunei Darussalam"
wgi$country[wgi$country=="Laos"] <- "Lao People's Democratic Republic"
wgi$country[wgi$country=="North Korea"] <- "Korea, Democratic People's Republic of"
wgi$country[wgi$country=="South Korea"] <- "Korea, Republic of"
wgi$country[wgi$country=="Hong Kong Sar, China"] <- "Hong Kong"
wgi$country[wgi$country=="Iran"] <- "Iran (Islamic Republic of)"
wgi$country[wgi$country=="Libya"] <- "Libyan Arab Jamahiriya"
wgi$country[wgi$country=="Macedonia, Fyr"] <- "The former Yugoslav Republic of Macedonia"
wgi$country[wgi$country=="Russian Federation"] <- "Russia"
wgi$country[wgi$country=="St. Vincent and The Grenadines"] <- "Saint Vincent and the Grenadines"
wgi$country[wgi$country=="St. Lucia"] <- "Saint Lucia"
wgi$country[wgi$country=="Syria"] <- "Syrian Arab Republic"
wgi$country[wgi$country=="Netherlands Antilles (former)"] <- "Netherlands Antilles"
wgi$country[wgi$country=="Timor-leste"] <- "Timor-Leste"
wgi$country[wgi$country=="Taiwan, China"] <- "Taiwan"
wgi$country[wgi$country=="Micronesia, Fed. Sts."] <- "Micronesia, Federated States of"
wgi$country[wgi$country=="Congo, Dem. Rep."] <- "Democratic Republic of the Congo"
wgi$country[wgi$country=="Venezuela, Rb"] <- "Venezuela"
wgi$country[wgi$country=="Virgin Islands (u.s.)"] <- "United States Virgin Islands"
wgi$country[wgi$country=="Vietnam"] <- "Viet Nam"
wgi$country[wgi$country=="Guinea-bissau"] <- "Guinea-Bissau"
wgi$country[wgi$country=="Congo Republic"] <- "Congo"
wgi$country[wgi$country=="CÃ´te D'ivoire"] <- "Cote d'Ivoire"
wgi$country[wgi$country=="Myanmar"] <- "Burma"
wgi$country[wgi$country=="SÃ£o TomÃ© and Principe"] <- "Sao Tome and Principe"
wgi$country[wgi$country=="Tanzania"] <- "United Republic of Tanzania"
wgi$country[wgi$country=="West Bank and Gaza"] <- "Palestine"
wgi$country[wgi$country=="Moldova"] <- "Republic of Moldova"
# Plot
saveHTML({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
theme(text=element_text(size=20)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
#     qplot(long, lat, data=choro, fill=cc_est, group=group, geom="polygon") +
#       scale_fill_gradient()
}
}, ani.basename="world_corruption", interval=1,
ani.width=900, ani.height=450,
outdir=getwd())
saveLatex({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
theme(text=element_text(size=20)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
#     qplot(long, lat, data=choro, fill=cc_est, group=group, geom="polygon") +
#       scale_fill_gradient()
}
}, ani.basename = "world_corruption", interval=1,
ani.width=900, ani.height=450,
ani.opts="autoplay,loop,controls,width=\\linewidth",
latex.filename = "world.corruption.tex",
outdir=getwd())
getwd()
View(wgi)
rm(list=ls())
toInstall <- c("ggplot2", "maptools", "animation", "rgdal")
lapply(toInstall, library, character.only=TRUE)
load('./data/wgi_cleaned.RData')
# Load world map shape file
world.map <- readOGR(dsn="./data", layer="TM_WORLD_BORDERS_SIMPL-0.3")
world.map <- readOGR(dsn="./data", layer="TM_WORLD_BORDERS_SIMPL-0.3")
world.ggmap <- fortify(world.map, region = "NAME")
fix(world.map)
wgi$country[wgi$country=="Brunei"] <- "Brunei Darussalam"
wgi$country[wgi$country=="Laos"] <- "Lao People's Democratic Republic"
wgi$country[wgi$country=="North Korea"] <- "Korea, Democratic People's Republic of"
wgi$country[wgi$country=="South Korea"] <- "Korea, Republic of"
wgi$country[wgi$country=="Hong Kong Sar, China"] <- "Hong Kong"
wgi$country[wgi$country=="Iran"] <- "Iran (Islamic Republic of)"
wgi$country[wgi$country=="Libya"] <- "Libyan Arab Jamahiriya"
wgi$country[wgi$country=="Macedonia, Fyr"] <- "The former Yugoslav Republic of Macedonia"
wgi$country[wgi$country=="Russian Federation"] <- "Russia"
wgi$country[wgi$country=="St. Vincent and The Grenadines"] <- "Saint Vincent and the Grenadines"
wgi$country[wgi$country=="St. Lucia"] <- "Saint Lucia"
wgi$country[wgi$country=="Syria"] <- "Syrian Arab Republic"
wgi$country[wgi$country=="Netherlands Antilles (former)"] <- "Netherlands Antilles"
wgi$country[wgi$country=="Timor-leste"] <- "Timor-Leste"
wgi$country[wgi$country=="Taiwan, China"] <- "Taiwan"
wgi$country[wgi$country=="Micronesia, Fed. Sts."] <- "Micronesia, Federated States of"
wgi$country[wgi$country=="Congo, Dem. Rep."] <- "Democratic Republic of the Congo"
wgi$country[wgi$country=="Venezuela, Rb"] <- "Venezuela"
wgi$country[wgi$country=="Virgin Islands (u.s.)"] <- "United States Virgin Islands"
wgi$country[wgi$country=="Vietnam"] <- "Viet Nam"
wgi$country[wgi$country=="Guinea-bissau"] <- "Guinea-Bissau"
wgi$country[wgi$country=="Congo Republic"] <- "Congo"
wgi$country[wgi$country=="CÃ´te D'ivoire"] <- "Cote d'Ivoire"
wgi$country[wgi$country=="Myanmar"] <- "Burma"
wgi$country[wgi$country=="SÃ£o TomÃ© and Principe"] <- "Sao Tome and Principe"
wgi$country[wgi$country=="Tanzania"] <- "United Republic of Tanzania"
wgi$country[wgi$country=="West Bank and Gaza"] <- "Palestine"
wgi$country[wgi$country=="Moldova"] <- "Republic of Moldova"
# Plot
saveHTML({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
theme(text=element_text(size=20)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
#     qplot(long, lat, data=choro, fill=cc_est, group=group, geom="polygon") +
#       scale_fill_gradient()
}
}, ani.basename="world_corruption", interval=1,
ani.width=900, ani.height=450,
outdir=getwd())
saveLatex({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
theme(text=element_text(size=20)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
#     qplot(long, lat, data=choro, fill=cc_est, group=group, geom="polygon") +
#       scale_fill_gradient()
}
}, ani.basename = "world_corruption", interval=1,
ani.width=900, ani.height=450,
ani.opts="autoplay,loop,controls,width=\\linewidth",
latex.filename = "world.corruption.tex",
outdir=getwd())
rm(list=ls())
toInstall <- c("ggplot2", "maptools", "animation", "rgdal")
lapply(toInstall, library, character.only=TRUE)
# Load and clean WGI data
load('./data/wgi_cleaned.RData')
# Load world map shape file
world.map <- readOGR(dsn="./data", layer="TM_WORLD_BORDERS_SIMPL-0.3")
world.ggmap <- fortify(world.map, region = "NAME")
# Fix mismatched names
wgi$country[wgi$country=="Brunei"] <- "Brunei Darussalam"
wgi$country[wgi$country=="Laos"] <- "Lao People's Democratic Republic"
wgi$country[wgi$country=="North Korea"] <- "Korea, Democratic People's Republic of"
wgi$country[wgi$country=="South Korea"] <- "Korea, Republic of"
wgi$country[wgi$country=="Hong Kong Sar, China"] <- "Hong Kong"
wgi$country[wgi$country=="Iran"] <- "Iran (Islamic Republic of)"
wgi$country[wgi$country=="Libya"] <- "Libyan Arab Jamahiriya"
wgi$country[wgi$country=="Macedonia, Fyr"] <- "The former Yugoslav Republic of Macedonia"
wgi$country[wgi$country=="Russian Federation"] <- "Russia"
wgi$country[wgi$country=="St. Vincent and The Grenadines"] <- "Saint Vincent and the Grenadines"
wgi$country[wgi$country=="St. Lucia"] <- "Saint Lucia"
wgi$country[wgi$country=="Syria"] <- "Syrian Arab Republic"
wgi$country[wgi$country=="Netherlands Antilles (former)"] <- "Netherlands Antilles"
wgi$country[wgi$country=="Timor-leste"] <- "Timor-Leste"
wgi$country[wgi$country=="Taiwan, China"] <- "Taiwan"
wgi$country[wgi$country=="Micronesia, Fed. Sts."] <- "Micronesia, Federated States of"
wgi$country[wgi$country=="Congo, Dem. Rep."] <- "Democratic Republic of the Congo"
wgi$country[wgi$country=="Venezuela, Rb"] <- "Venezuela"
wgi$country[wgi$country=="Virgin Islands (u.s.)"] <- "United States Virgin Islands"
wgi$country[wgi$country=="Vietnam"] <- "Viet Nam"
wgi$country[wgi$country=="Guinea-bissau"] <- "Guinea-Bissau"
wgi$country[wgi$country=="Congo Republic"] <- "Congo"
wgi$country[wgi$country=="CÃ´te D'ivoire"] <- "Cote d'Ivoire"
wgi$country[wgi$country=="Myanmar"] <- "Burma"
wgi$country[wgi$country=="SÃ£o TomÃ© and Principe"] <- "Sao Tome and Principe"
wgi$country[wgi$country=="Tanzania"] <- "United Republic of Tanzania"
wgi$country[wgi$country=="West Bank and Gaza"] <- "Palestine"
wgi$country[wgi$country=="Moldova"] <- "Republic of Moldova"
# Plot
saveHTML({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
}
}, ani.basename="world_corruption", interval=1,
ani.width=900, ani.height=450,
outdir=getwd())
saveLatex({
for (i in c(1996, 1998, 2000, 2002:2011)) {
temp <- subset(na.omit(wgi[, c('year', 'country', 'cc_est')]), year==i)
choro <- merge(world.ggmap, temp, by.x="id", by.y="country")
choro <- choro[order(choro$order), ]
p <- ggplot(data=choro, aes(long, lat, fill=cc_est, group=group))
print(
p + geom_polygon() + ylim(c(-60,85)) +
scale_fill_gradient2("Control of\n corruption\n score", limits=c(-2.5,2.5)) +
labs(title=substitute(paste("Severity of corruption in the world, year ", i), list(i=i)))
)
}
}, ani.basename = "world_corruption", interval=1,
ani.width=900, ani.height=450,
ani.opts="autoplay,loop,controls,width=\\linewidth",
latex.filename = "world.corruption.tex",
outdir=getwd())
